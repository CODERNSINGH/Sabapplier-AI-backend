import google.generativeai as genai
from django.conf import settings
from openai import OpenAI
from bs4 import BeautifulSoup
import json
import os

def extract_form_only(raw_html):
    soup = BeautifulSoup(raw_html, 'html.parser')
    forms = soup.find_all('form')
    return '\n'.join(str(form) for form in forms)


# Gemini + Gemini (2.0 Flash) -- 1st response -> 2nd response (review and update)
def get_autofill_data(raw_html, user_data):
    try:
        import os
        api_key = os.getenv("api_key")
        open_ai_api_key = os.getenv("api_key")
        form_data = extract_form_only(raw_html)

        # Stage 1: Prompt to generate autofill data
        instructions = (
            "### TASK:\n"
            "You are given raw HTML and user JSON. For each and every input field:\n"
            "I want to fill the html form, so help me to fill it using extension script feature, so for that give me output accordingly such that I can fill that data.\n"
            "1. Identify the matching form field using input[name=''], or '.class_name', or '#id' (prefer name).\n"
            "2. For input fields and textareas, fill with relevant user data or similar to it.\n"
            "3. For select fields, choose the most relevant option based on user data, just give the value of the option don't generate anything else\n"
            "4. For radio buttons, select the most relevant option based on user data\n"
            "5. For checkboxes, check the most relevant options based on user data, else check the last option.\n"
            "6. For file inputs, provide 'file url from the user data' as a filled value.\n"
            "### SPECIAL INSTRUCTIONS FOR FIELD TYPES:\n"
            "- For <select> dropdowns: match the name or id, and select the value closest to user data. If a match isn‚Äôt obvious, choose a logically relevant value.\n"
            "- For file inputs: if user JSON contains file URL or document name, assign it. Else, use 'NA'.\n"
            "- For checkboxes or radios: assign 'checked' if the value applies to user, otherwise 'unchecked'.\n"
            "- Always include 'type': 'select', 'file', 'checkbox', 'radio', or 'input' as appropriate.\n"
            "\n\nExample output:"
            "[\n"
            "  {'input[name=\"username\"]': 'JohnDoe', 'type': 'input'},\n"
            "  {'input[name=\"email\"]': 'john@email.com', 'type': 'file'}\n"
            "]\n"
            "### Note: don't generate anything else, any explanations, just give json output as specified\n"
        )

        # Combine input
        prompt_stage_1 = f"Website Text: {form_data}\nUser JSON: {user_data}\n\n{instructions}"

        # Stage 1: Use Gemini Flash to generate raw autofill data
        
        client = OpenAI(api_key= open_ai_api_key)
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                    {"role": "user", "content": prompt_stage_1},
                ],
        ) 
        res_text = response.choices[0].message.content.strip()
        res_text = "".join(res_text.split('\n')[1:-1]).strip()  # Remove any leading/trailing whitespace
        try:
            parsed_json = json.loads(res_text)
            autofillData = json.dumps(parsed_json)  # Serialize to string, safe for frontend JSON.parse
        except json.JSONDecodeError as e:
            print(f"‚ùå JSON parsing error: {e}")
            autofillData = res_text
        print("\nautofillData (JSON string):", autofillData)
        return autofillData
    except Exception as e:
        print(f"‚ùå Error in get_autofill_data: {e}")
        return {}

    # raw_autofill = "".join(res_text.split('\n')[1:-1]).strip()

    # print("üîπ Stage 1 autofill data (raw):", raw_autofill)

    # # Stage 2: Prompt to review and correct autofill data
    # review_prompt = (
    #     "### TASK:\n"
    #     "You are given HTML form content and user data, along with autofill JSONs generated by another AI model.\n"
    #     "Your job is to **review** and **improve the accuracy** of the autofill data by:\n"
    #     "- Validating matches between field names and user data\n"
    #     "1. For input fields and textareas, fill with relevant user data or similar to it.\n"
    #     "2. For select fields, choose the most relevant option based on user data, just give the value of the option don't generate anything else\n"
    #     "3. For radio buttons, select the most relevant option based on user data\n"
    #     "4. For checkboxes, check the most relevant options based on user data, else check the last option.\n"
    #     "5. For file inputs, provide 'file url from the user data' as a filled value.\n"
    #     f"Website HTML:\n{form_data}\n\nUser JSON:\n{user_data}\n\nAI-generated autofill JSON:\n{raw_autofill}\n\n"
    #     "- Correcting field values if needed\n"
    #     "- Ensuring logical matches for select/dropdowns, checkboxes, and files\n"
    #     "- Fixing inconsistent or obviously wrong values\n\n"
    #     "dont generate anything, any explanations or anything except json response\n"
    # )

    # # Stage 2: Use Gemini 1.5 Pro to review and refine
    # open_ai_api_key = "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"
    # client = OpenAI(api_key= open_ai_api_key)
    # response = client.chat.completions.create(
    #     model="gpt-4.1-nano",
    #     messages=[
    #             {"role": "user", "content": review_prompt},
    #         ],
    # ) 
    # res_text = response.choices[0].message.content.strip()
    # try:
    #     parsed_json = json.loads(res_text)
    #     autofillData = json.dumps(parsed_json)  # Serialize to string, safe for frontend JSON.parse
    # except json.JSONDecodeError as e:
    #     print(f"‚ùå JSON parsing error: {e}")
    #     autofillData = res_text

    # print("\nautofillData (JSON string):", autofillData)
    # return autofillData
